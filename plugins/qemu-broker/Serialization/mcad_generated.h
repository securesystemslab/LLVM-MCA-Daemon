// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MCAD_LLVM_MCAD_FBS_H_
#define FLATBUFFERS_GENERATED_MCAD_LLVM_MCAD_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace llvm {
namespace mcad {
namespace fbs {

struct Metadata;
struct MetadataBuilder;

struct MemoryAccess;

struct ExecTB;
struct ExecTBBuilder;

struct Inst;
struct InstBuilder;

struct TranslatedBlock;
struct TranslatedBlockBuilder;

struct Message;
struct MessageBuilder;

enum Msg {
  Msg_NONE = 0,
  Msg_Metadata = 1,
  Msg_ExecTB = 2,
  Msg_TranslatedBlock = 3,
  Msg_MIN = Msg_NONE,
  Msg_MAX = Msg_TranslatedBlock
};

inline const Msg (&EnumValuesMsg())[4] {
  static const Msg values[] = {
    Msg_NONE,
    Msg_Metadata,
    Msg_ExecTB,
    Msg_TranslatedBlock
  };
  return values;
}

inline const char * const *EnumNamesMsg() {
  static const char * const names[5] = {
    "NONE",
    "Metadata",
    "ExecTB",
    "TranslatedBlock",
    nullptr
  };
  return names;
}

inline const char *EnumNameMsg(Msg e) {
  if (flatbuffers::IsOutRange(e, Msg_NONE, Msg_TranslatedBlock)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMsg()[index];
}

template<typename T> struct MsgTraits {
  static const Msg enum_value = Msg_NONE;
};

template<> struct MsgTraits<llvm::mcad::fbs::Metadata> {
  static const Msg enum_value = Msg_Metadata;
};

template<> struct MsgTraits<llvm::mcad::fbs::ExecTB> {
  static const Msg enum_value = Msg_ExecTB;
};

template<> struct MsgTraits<llvm::mcad::fbs::TranslatedBlock> {
  static const Msg enum_value = Msg_TranslatedBlock;
};

bool VerifyMsg(flatbuffers::Verifier &verifier, const void *obj, Msg type);
bool VerifyMsgVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) MemoryAccess FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t Index_;
  int32_t padding0__;
  uint64_t VAddr_;
  uint8_t Size_;
  uint8_t IsStore_;
  int16_t padding1__;  int32_t padding2__;

 public:
  MemoryAccess()
      : Index_(0),
        padding0__(0),
        VAddr_(0),
        Size_(0),
        IsStore_(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  MemoryAccess(uint32_t _Index, uint64_t _VAddr, uint8_t _Size, bool _IsStore)
      : Index_(flatbuffers::EndianScalar(_Index)),
        padding0__(0),
        VAddr_(flatbuffers::EndianScalar(_VAddr)),
        Size_(flatbuffers::EndianScalar(_Size)),
        IsStore_(flatbuffers::EndianScalar(static_cast<uint8_t>(_IsStore))),
        padding1__(0),
        padding2__(0) {
  }
  uint32_t Index() const {
    return flatbuffers::EndianScalar(Index_);
  }
  uint64_t VAddr() const {
    return flatbuffers::EndianScalar(VAddr_);
  }
  uint8_t Size() const {
    return flatbuffers::EndianScalar(Size_);
  }
  bool IsStore() const {
    return flatbuffers::EndianScalar(IsStore_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(MemoryAccess, 24);

struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOADADDR = 4
  };
  uint64_t LoadAddr() const {
    return GetField<uint64_t>(VT_LOADADDR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LOADADDR) &&
           verifier.EndTable();
  }
};

struct MetadataBuilder {
  typedef Metadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_LoadAddr(uint64_t LoadAddr) {
    fbb_.AddElement<uint64_t>(Metadata::VT_LOADADDR, LoadAddr, 0);
  }
  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metadata> CreateMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t LoadAddr = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_LoadAddr(LoadAddr);
  return builder_.Finish();
}

struct ExecTB FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecTBBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_PC = 6,
    VT_MEMACCESSES = 8
  };
  uint32_t Index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  uint64_t PC() const {
    return GetField<uint64_t>(VT_PC, 0);
  }
  const flatbuffers::Vector<const llvm::mcad::fbs::MemoryAccess *> *MemAccesses() const {
    return GetPointer<const flatbuffers::Vector<const llvm::mcad::fbs::MemoryAccess *> *>(VT_MEMACCESSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INDEX) &&
           VerifyField<uint64_t>(verifier, VT_PC) &&
           VerifyOffset(verifier, VT_MEMACCESSES) &&
           verifier.VerifyVector(MemAccesses()) &&
           verifier.EndTable();
  }
};

struct ExecTBBuilder {
  typedef ExecTB Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Index(uint32_t Index) {
    fbb_.AddElement<uint32_t>(ExecTB::VT_INDEX, Index, 0);
  }
  void add_PC(uint64_t PC) {
    fbb_.AddElement<uint64_t>(ExecTB::VT_PC, PC, 0);
  }
  void add_MemAccesses(flatbuffers::Offset<flatbuffers::Vector<const llvm::mcad::fbs::MemoryAccess *>> MemAccesses) {
    fbb_.AddOffset(ExecTB::VT_MEMACCESSES, MemAccesses);
  }
  explicit ExecTBBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecTB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecTB>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecTB> CreateExecTB(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Index = 0,
    uint64_t PC = 0,
    flatbuffers::Offset<flatbuffers::Vector<const llvm::mcad::fbs::MemoryAccess *>> MemAccesses = 0) {
  ExecTBBuilder builder_(_fbb);
  builder_.add_PC(PC);
  builder_.add_MemAccesses(MemAccesses);
  builder_.add_Index(Index);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecTB> CreateExecTBDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Index = 0,
    uint64_t PC = 0,
    const std::vector<llvm::mcad::fbs::MemoryAccess> *MemAccesses = nullptr) {
  auto MemAccesses__ = MemAccesses ? _fbb.CreateVectorOfStructs<llvm::mcad::fbs::MemoryAccess>(*MemAccesses) : 0;
  return llvm::mcad::fbs::CreateExecTB(
      _fbb,
      Index,
      PC,
      MemAccesses__);
}

struct Inst FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *Data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(Data()) &&
           verifier.EndTable();
  }
};

struct InstBuilder {
  typedef Inst Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Data) {
    fbb_.AddOffset(Inst::VT_DATA, Data);
  }
  explicit InstBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Inst> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Inst>(end);
    return o;
  }
};

inline flatbuffers::Offset<Inst> CreateInst(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Data = 0) {
  InstBuilder builder_(_fbb);
  builder_.add_Data(Data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Inst> CreateInstDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *Data = nullptr) {
  auto Data__ = Data ? _fbb.CreateVector<uint8_t>(*Data) : 0;
  return llvm::mcad::fbs::CreateInst(
      _fbb,
      Data__);
}

struct TranslatedBlock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TranslatedBlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_INSTRUCTIONS = 6
  };
  uint32_t Index() const {
    return GetField<uint32_t>(VT_INDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<llvm::mcad::fbs::Inst>> *Instructions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<llvm::mcad::fbs::Inst>> *>(VT_INSTRUCTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_INSTRUCTIONS) &&
           verifier.VerifyVector(Instructions()) &&
           verifier.VerifyVectorOfTables(Instructions()) &&
           verifier.EndTable();
  }
};

struct TranslatedBlockBuilder {
  typedef TranslatedBlock Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Index(uint32_t Index) {
    fbb_.AddElement<uint32_t>(TranslatedBlock::VT_INDEX, Index, 0);
  }
  void add_Instructions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<llvm::mcad::fbs::Inst>>> Instructions) {
    fbb_.AddOffset(TranslatedBlock::VT_INSTRUCTIONS, Instructions);
  }
  explicit TranslatedBlockBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TranslatedBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TranslatedBlock>(end);
    return o;
  }
};

inline flatbuffers::Offset<TranslatedBlock> CreateTranslatedBlock(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Index = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<llvm::mcad::fbs::Inst>>> Instructions = 0) {
  TranslatedBlockBuilder builder_(_fbb);
  builder_.add_Instructions(Instructions);
  builder_.add_Index(Index);
  return builder_.Finish();
}

inline flatbuffers::Offset<TranslatedBlock> CreateTranslatedBlockDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t Index = 0,
    const std::vector<flatbuffers::Offset<llvm::mcad::fbs::Inst>> *Instructions = nullptr) {
  auto Instructions__ = Instructions ? _fbb.CreateVector<flatbuffers::Offset<llvm::mcad::fbs::Inst>>(*Instructions) : 0;
  return llvm::mcad::fbs::CreateTranslatedBlock(
      _fbb,
      Index,
      Instructions__);
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT_TYPE = 4,
    VT_CONTENT = 6
  };
  llvm::mcad::fbs::Msg Content_type() const {
    return static_cast<llvm::mcad::fbs::Msg>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *Content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *Content_as() const;
  const llvm::mcad::fbs::Metadata *Content_as_Metadata() const {
    return Content_type() == llvm::mcad::fbs::Msg_Metadata ? static_cast<const llvm::mcad::fbs::Metadata *>(Content()) : nullptr;
  }
  const llvm::mcad::fbs::ExecTB *Content_as_ExecTB() const {
    return Content_type() == llvm::mcad::fbs::Msg_ExecTB ? static_cast<const llvm::mcad::fbs::ExecTB *>(Content()) : nullptr;
  }
  const llvm::mcad::fbs::TranslatedBlock *Content_as_TranslatedBlock() const {
    return Content_type() == llvm::mcad::fbs::Msg_TranslatedBlock ? static_cast<const llvm::mcad::fbs::TranslatedBlock *>(Content()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyMsg(verifier, Content(), Content_type()) &&
           verifier.EndTable();
  }
};

template<> inline const llvm::mcad::fbs::Metadata *Message::Content_as<llvm::mcad::fbs::Metadata>() const {
  return Content_as_Metadata();
}

template<> inline const llvm::mcad::fbs::ExecTB *Message::Content_as<llvm::mcad::fbs::ExecTB>() const {
  return Content_as_ExecTB();
}

template<> inline const llvm::mcad::fbs::TranslatedBlock *Message::Content_as<llvm::mcad::fbs::TranslatedBlock>() const {
  return Content_as_TranslatedBlock();
}

struct MessageBuilder {
  typedef Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Content_type(llvm::mcad::fbs::Msg Content_type) {
    fbb_.AddElement<uint8_t>(Message::VT_CONTENT_TYPE, static_cast<uint8_t>(Content_type), 0);
  }
  void add_Content(flatbuffers::Offset<void> Content) {
    fbb_.AddOffset(Message::VT_CONTENT, Content);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    llvm::mcad::fbs::Msg Content_type = llvm::mcad::fbs::Msg_NONE,
    flatbuffers::Offset<void> Content = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_Content(Content);
  builder_.add_Content_type(Content_type);
  return builder_.Finish();
}

inline bool VerifyMsg(flatbuffers::Verifier &verifier, const void *obj, Msg type) {
  switch (type) {
    case Msg_NONE: {
      return true;
    }
    case Msg_Metadata: {
      auto ptr = reinterpret_cast<const llvm::mcad::fbs::Metadata *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Msg_ExecTB: {
      auto ptr = reinterpret_cast<const llvm::mcad::fbs::ExecTB *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Msg_TranslatedBlock: {
      auto ptr = reinterpret_cast<const llvm::mcad::fbs::TranslatedBlock *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMsgVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMsg(
        verifier,  values->Get(i), types->GetEnum<Msg>(i))) {
      return false;
    }
  }
  return true;
}

inline const llvm::mcad::fbs::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<llvm::mcad::fbs::Message>(buf);
}

inline const llvm::mcad::fbs::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<llvm::mcad::fbs::Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<llvm::mcad::fbs::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<llvm::mcad::fbs::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<llvm::mcad::fbs::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<llvm::mcad::fbs::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs
}  // namespace mcad
}  // namespace llvm

#endif  // FLATBUFFERS_GENERATED_MCAD_LLVM_MCAD_FBS_H_
