// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: emulator.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_emulator_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_emulator_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_emulator_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_emulator_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_emulator_2eproto;
class EmulatorActions;
class EmulatorActionsDefaultTypeInternal;
extern EmulatorActionsDefaultTypeInternal _EmulatorActions_default_instance_;
class EmulatorActions_BranchFlow;
class EmulatorActions_BranchFlowDefaultTypeInternal;
extern EmulatorActions_BranchFlowDefaultTypeInternal _EmulatorActions_BranchFlow_default_instance_;
class EmulatorActions_Instruction;
class EmulatorActions_InstructionDefaultTypeInternal;
extern EmulatorActions_InstructionDefaultTypeInternal _EmulatorActions_Instruction_default_instance_;
class EmulatorActions_MemoryAccess;
class EmulatorActions_MemoryAccessDefaultTypeInternal;
extern EmulatorActions_MemoryAccessDefaultTypeInternal _EmulatorActions_MemoryAccess_default_instance_;
class NextAction;
class NextActionDefaultTypeInternal;
extern NextActionDefaultTypeInternal _NextAction_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::EmulatorActions* Arena::CreateMaybeMessage<::EmulatorActions>(Arena*);
template<> ::EmulatorActions_BranchFlow* Arena::CreateMaybeMessage<::EmulatorActions_BranchFlow>(Arena*);
template<> ::EmulatorActions_Instruction* Arena::CreateMaybeMessage<::EmulatorActions_Instruction>(Arena*);
template<> ::EmulatorActions_MemoryAccess* Arena::CreateMaybeMessage<::EmulatorActions_MemoryAccess>(Arena*);
template<> ::NextAction* Arena::CreateMaybeMessage<::NextAction>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class NextAction PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NextAction) */ {
 public:
  inline NextAction() : NextAction(nullptr) {};
  virtual ~NextAction();

  NextAction(const NextAction& from);
  NextAction(NextAction&& from) noexcept
    : NextAction() {
    *this = ::std::move(from);
  }

  inline NextAction& operator=(const NextAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextAction& operator=(NextAction&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NextAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NextAction* internal_default_instance() {
    return reinterpret_cast<const NextAction*>(
               &_NextAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NextAction& a, NextAction& b) {
    a.Swap(&b);
  }
  inline void Swap(NextAction* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NextAction* New() const final {
    return CreateMaybeMessage<NextAction>(nullptr);
  }

  NextAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NextAction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NextAction& from);
  void MergeFrom(const NextAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NextAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NextAction";
  }
  protected:
  explicit NextAction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_2eproto);
    return ::descriptor_table_emulator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumInstructionsFieldNumber = 1,
  };
  // int32 num_instructions = 1;
  bool has_num_instructions() const;
  private:
  bool _internal_has_num_instructions() const;
  public:
  void clear_num_instructions();
  ::PROTOBUF_NAMESPACE_ID::int32 num_instructions() const;
  void set_num_instructions(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_instructions() const;
  void _internal_set_num_instructions(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:NextAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_instructions_;
  friend struct ::TableStruct_emulator_2eproto;
};
// -------------------------------------------------------------------

class EmulatorActions_MemoryAccess PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EmulatorActions.MemoryAccess) */ {
 public:
  inline EmulatorActions_MemoryAccess() : EmulatorActions_MemoryAccess(nullptr) {};
  virtual ~EmulatorActions_MemoryAccess();

  EmulatorActions_MemoryAccess(const EmulatorActions_MemoryAccess& from);
  EmulatorActions_MemoryAccess(EmulatorActions_MemoryAccess&& from) noexcept
    : EmulatorActions_MemoryAccess() {
    *this = ::std::move(from);
  }

  inline EmulatorActions_MemoryAccess& operator=(const EmulatorActions_MemoryAccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmulatorActions_MemoryAccess& operator=(EmulatorActions_MemoryAccess&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EmulatorActions_MemoryAccess& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmulatorActions_MemoryAccess* internal_default_instance() {
    return reinterpret_cast<const EmulatorActions_MemoryAccess*>(
               &_EmulatorActions_MemoryAccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(EmulatorActions_MemoryAccess& a, EmulatorActions_MemoryAccess& b) {
    a.Swap(&b);
  }
  inline void Swap(EmulatorActions_MemoryAccess* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmulatorActions_MemoryAccess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmulatorActions_MemoryAccess* New() const final {
    return CreateMaybeMessage<EmulatorActions_MemoryAccess>(nullptr);
  }

  EmulatorActions_MemoryAccess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmulatorActions_MemoryAccess>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EmulatorActions_MemoryAccess& from);
  void MergeFrom(const EmulatorActions_MemoryAccess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmulatorActions_MemoryAccess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EmulatorActions.MemoryAccess";
  }
  protected:
  explicit EmulatorActions_MemoryAccess(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_2eproto);
    return ::descriptor_table_emulator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVaddrFieldNumber = 1,
    kSizeFieldNumber = 2,
    kIsStoreFieldNumber = 3,
  };
  // uint64 vaddr = 1;
  void clear_vaddr();
  ::PROTOBUF_NAMESPACE_ID::uint64 vaddr() const;
  void set_vaddr(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_vaddr() const;
  void _internal_set_vaddr(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 size = 2;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool is_store = 3;
  void clear_is_store();
  bool is_store() const;
  void set_is_store(bool value);
  private:
  bool _internal_is_store() const;
  void _internal_set_is_store(bool value);
  public:

  // @@protoc_insertion_point(class_scope:EmulatorActions.MemoryAccess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 vaddr_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  bool is_store_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_2eproto;
};
// -------------------------------------------------------------------

class EmulatorActions_BranchFlow PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EmulatorActions.BranchFlow) */ {
 public:
  inline EmulatorActions_BranchFlow() : EmulatorActions_BranchFlow(nullptr) {};
  virtual ~EmulatorActions_BranchFlow();

  EmulatorActions_BranchFlow(const EmulatorActions_BranchFlow& from);
  EmulatorActions_BranchFlow(EmulatorActions_BranchFlow&& from) noexcept
    : EmulatorActions_BranchFlow() {
    *this = ::std::move(from);
  }

  inline EmulatorActions_BranchFlow& operator=(const EmulatorActions_BranchFlow& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmulatorActions_BranchFlow& operator=(EmulatorActions_BranchFlow&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EmulatorActions_BranchFlow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmulatorActions_BranchFlow* internal_default_instance() {
    return reinterpret_cast<const EmulatorActions_BranchFlow*>(
               &_EmulatorActions_BranchFlow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EmulatorActions_BranchFlow& a, EmulatorActions_BranchFlow& b) {
    a.Swap(&b);
  }
  inline void Swap(EmulatorActions_BranchFlow* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmulatorActions_BranchFlow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmulatorActions_BranchFlow* New() const final {
    return CreateMaybeMessage<EmulatorActions_BranchFlow>(nullptr);
  }

  EmulatorActions_BranchFlow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmulatorActions_BranchFlow>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EmulatorActions_BranchFlow& from);
  void MergeFrom(const EmulatorActions_BranchFlow& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmulatorActions_BranchFlow* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EmulatorActions.BranchFlow";
  }
  protected:
  explicit EmulatorActions_BranchFlow(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_2eproto);
    return ::descriptor_table_emulator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsMispredictFieldNumber = 1,
  };
  // bool is_mispredict = 1;
  void clear_is_mispredict();
  bool is_mispredict() const;
  void set_is_mispredict(bool value);
  private:
  bool _internal_is_mispredict() const;
  void _internal_set_is_mispredict(bool value);
  public:

  // @@protoc_insertion_point(class_scope:EmulatorActions.BranchFlow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_mispredict_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_2eproto;
};
// -------------------------------------------------------------------

class EmulatorActions_Instruction PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EmulatorActions.Instruction) */ {
 public:
  inline EmulatorActions_Instruction() : EmulatorActions_Instruction(nullptr) {};
  virtual ~EmulatorActions_Instruction();

  EmulatorActions_Instruction(const EmulatorActions_Instruction& from);
  EmulatorActions_Instruction(EmulatorActions_Instruction&& from) noexcept
    : EmulatorActions_Instruction() {
    *this = ::std::move(from);
  }

  inline EmulatorActions_Instruction& operator=(const EmulatorActions_Instruction& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmulatorActions_Instruction& operator=(EmulatorActions_Instruction&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EmulatorActions_Instruction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmulatorActions_Instruction* internal_default_instance() {
    return reinterpret_cast<const EmulatorActions_Instruction*>(
               &_EmulatorActions_Instruction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EmulatorActions_Instruction& a, EmulatorActions_Instruction& b) {
    a.Swap(&b);
  }
  inline void Swap(EmulatorActions_Instruction* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmulatorActions_Instruction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmulatorActions_Instruction* New() const final {
    return CreateMaybeMessage<EmulatorActions_Instruction>(nullptr);
  }

  EmulatorActions_Instruction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmulatorActions_Instruction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EmulatorActions_Instruction& from);
  void MergeFrom(const EmulatorActions_Instruction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmulatorActions_Instruction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EmulatorActions.Instruction";
  }
  protected:
  explicit EmulatorActions_Instruction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_2eproto);
    return ::descriptor_table_emulator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpcodeFieldNumber = 1,
    kMemoryAccessFieldNumber = 4,
    kBranchFlowFieldNumber = 5,
    kAddrFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  // bytes opcode = 1;
  void clear_opcode();
  const std::string& opcode() const;
  void set_opcode(const std::string& value);
  void set_opcode(std::string&& value);
  void set_opcode(const char* value);
  void set_opcode(const void* value, size_t size);
  std::string* mutable_opcode();
  std::string* release_opcode();
  void set_allocated_opcode(std::string* opcode);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_opcode();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_opcode(
      std::string* opcode);
  private:
  const std::string& _internal_opcode() const;
  void _internal_set_opcode(const std::string& value);
  std::string* _internal_mutable_opcode();
  public:

  // .EmulatorActions.MemoryAccess memory_access = 4;
  bool has_memory_access() const;
  private:
  bool _internal_has_memory_access() const;
  public:
  void clear_memory_access();
  const ::EmulatorActions_MemoryAccess& memory_access() const;
  ::EmulatorActions_MemoryAccess* release_memory_access();
  ::EmulatorActions_MemoryAccess* mutable_memory_access();
  void set_allocated_memory_access(::EmulatorActions_MemoryAccess* memory_access);
  private:
  const ::EmulatorActions_MemoryAccess& _internal_memory_access() const;
  ::EmulatorActions_MemoryAccess* _internal_mutable_memory_access();
  public:
  void unsafe_arena_set_allocated_memory_access(
      ::EmulatorActions_MemoryAccess* memory_access);
  ::EmulatorActions_MemoryAccess* unsafe_arena_release_memory_access();

  // .EmulatorActions.BranchFlow branch_flow = 5;
  bool has_branch_flow() const;
  private:
  bool _internal_has_branch_flow() const;
  public:
  void clear_branch_flow();
  const ::EmulatorActions_BranchFlow& branch_flow() const;
  ::EmulatorActions_BranchFlow* release_branch_flow();
  ::EmulatorActions_BranchFlow* mutable_branch_flow();
  void set_allocated_branch_flow(::EmulatorActions_BranchFlow* branch_flow);
  private:
  const ::EmulatorActions_BranchFlow& _internal_branch_flow() const;
  ::EmulatorActions_BranchFlow* _internal_mutable_branch_flow();
  public:
  void unsafe_arena_set_allocated_branch_flow(
      ::EmulatorActions_BranchFlow* branch_flow);
  ::EmulatorActions_BranchFlow* unsafe_arena_release_branch_flow();

  // uint64 addr = 2;
  void clear_addr();
  ::PROTOBUF_NAMESPACE_ID::uint64 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_addr() const;
  void _internal_set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 size = 3;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:EmulatorActions.Instruction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opcode_;
  ::EmulatorActions_MemoryAccess* memory_access_;
  ::EmulatorActions_BranchFlow* branch_flow_;
  ::PROTOBUF_NAMESPACE_ID::uint64 addr_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  friend struct ::TableStruct_emulator_2eproto;
};
// -------------------------------------------------------------------

class EmulatorActions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EmulatorActions) */ {
 public:
  inline EmulatorActions() : EmulatorActions(nullptr) {};
  virtual ~EmulatorActions();

  EmulatorActions(const EmulatorActions& from);
  EmulatorActions(EmulatorActions&& from) noexcept
    : EmulatorActions() {
    *this = ::std::move(from);
  }

  inline EmulatorActions& operator=(const EmulatorActions& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmulatorActions& operator=(EmulatorActions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EmulatorActions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmulatorActions* internal_default_instance() {
    return reinterpret_cast<const EmulatorActions*>(
               &_EmulatorActions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EmulatorActions& a, EmulatorActions& b) {
    a.Swap(&b);
  }
  inline void Swap(EmulatorActions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmulatorActions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmulatorActions* New() const final {
    return CreateMaybeMessage<EmulatorActions>(nullptr);
  }

  EmulatorActions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmulatorActions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EmulatorActions& from);
  void MergeFrom(const EmulatorActions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmulatorActions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EmulatorActions";
  }
  protected:
  explicit EmulatorActions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_emulator_2eproto);
    return ::descriptor_table_emulator_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef EmulatorActions_MemoryAccess MemoryAccess;
  typedef EmulatorActions_BranchFlow BranchFlow;
  typedef EmulatorActions_Instruction Instruction;

  // accessors -------------------------------------------------------

  enum : int {
    kInstructionsFieldNumber = 1,
  };
  // repeated .EmulatorActions.Instruction instructions = 1;
  int instructions_size() const;
  private:
  int _internal_instructions_size() const;
  public:
  void clear_instructions();
  ::EmulatorActions_Instruction* mutable_instructions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EmulatorActions_Instruction >*
      mutable_instructions();
  private:
  const ::EmulatorActions_Instruction& _internal_instructions(int index) const;
  ::EmulatorActions_Instruction* _internal_add_instructions();
  public:
  const ::EmulatorActions_Instruction& instructions(int index) const;
  ::EmulatorActions_Instruction* add_instructions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EmulatorActions_Instruction >&
      instructions() const;

  // @@protoc_insertion_point(class_scope:EmulatorActions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EmulatorActions_Instruction > instructions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_emulator_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NextAction

// int32 num_instructions = 1;
inline bool NextAction::_internal_has_num_instructions() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NextAction::has_num_instructions() const {
  return _internal_has_num_instructions();
}
inline void NextAction::clear_num_instructions() {
  num_instructions_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NextAction::_internal_num_instructions() const {
  return num_instructions_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NextAction::num_instructions() const {
  // @@protoc_insertion_point(field_get:NextAction.num_instructions)
  return _internal_num_instructions();
}
inline void NextAction::_internal_set_num_instructions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  num_instructions_ = value;
}
inline void NextAction::set_num_instructions(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_instructions(value);
  // @@protoc_insertion_point(field_set:NextAction.num_instructions)
}

// -------------------------------------------------------------------

// EmulatorActions_MemoryAccess

// uint64 vaddr = 1;
inline void EmulatorActions_MemoryAccess::clear_vaddr() {
  vaddr_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EmulatorActions_MemoryAccess::_internal_vaddr() const {
  return vaddr_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EmulatorActions_MemoryAccess::vaddr() const {
  // @@protoc_insertion_point(field_get:EmulatorActions.MemoryAccess.vaddr)
  return _internal_vaddr();
}
inline void EmulatorActions_MemoryAccess::_internal_set_vaddr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  vaddr_ = value;
}
inline void EmulatorActions_MemoryAccess::set_vaddr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_vaddr(value);
  // @@protoc_insertion_point(field_set:EmulatorActions.MemoryAccess.vaddr)
}

// uint32 size = 2;
inline void EmulatorActions_MemoryAccess::clear_size() {
  size_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EmulatorActions_MemoryAccess::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EmulatorActions_MemoryAccess::size() const {
  // @@protoc_insertion_point(field_get:EmulatorActions.MemoryAccess.size)
  return _internal_size();
}
inline void EmulatorActions_MemoryAccess::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  size_ = value;
}
inline void EmulatorActions_MemoryAccess::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:EmulatorActions.MemoryAccess.size)
}

// bool is_store = 3;
inline void EmulatorActions_MemoryAccess::clear_is_store() {
  is_store_ = false;
}
inline bool EmulatorActions_MemoryAccess::_internal_is_store() const {
  return is_store_;
}
inline bool EmulatorActions_MemoryAccess::is_store() const {
  // @@protoc_insertion_point(field_get:EmulatorActions.MemoryAccess.is_store)
  return _internal_is_store();
}
inline void EmulatorActions_MemoryAccess::_internal_set_is_store(bool value) {
  
  is_store_ = value;
}
inline void EmulatorActions_MemoryAccess::set_is_store(bool value) {
  _internal_set_is_store(value);
  // @@protoc_insertion_point(field_set:EmulatorActions.MemoryAccess.is_store)
}

// -------------------------------------------------------------------

// EmulatorActions_BranchFlow

// bool is_mispredict = 1;
inline void EmulatorActions_BranchFlow::clear_is_mispredict() {
  is_mispredict_ = false;
}
inline bool EmulatorActions_BranchFlow::_internal_is_mispredict() const {
  return is_mispredict_;
}
inline bool EmulatorActions_BranchFlow::is_mispredict() const {
  // @@protoc_insertion_point(field_get:EmulatorActions.BranchFlow.is_mispredict)
  return _internal_is_mispredict();
}
inline void EmulatorActions_BranchFlow::_internal_set_is_mispredict(bool value) {
  
  is_mispredict_ = value;
}
inline void EmulatorActions_BranchFlow::set_is_mispredict(bool value) {
  _internal_set_is_mispredict(value);
  // @@protoc_insertion_point(field_set:EmulatorActions.BranchFlow.is_mispredict)
}

// -------------------------------------------------------------------

// EmulatorActions_Instruction

// bytes opcode = 1;
inline void EmulatorActions_Instruction::clear_opcode() {
  opcode_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& EmulatorActions_Instruction::opcode() const {
  // @@protoc_insertion_point(field_get:EmulatorActions.Instruction.opcode)
  return _internal_opcode();
}
inline void EmulatorActions_Instruction::set_opcode(const std::string& value) {
  _internal_set_opcode(value);
  // @@protoc_insertion_point(field_set:EmulatorActions.Instruction.opcode)
}
inline std::string* EmulatorActions_Instruction::mutable_opcode() {
  // @@protoc_insertion_point(field_mutable:EmulatorActions.Instruction.opcode)
  return _internal_mutable_opcode();
}
inline const std::string& EmulatorActions_Instruction::_internal_opcode() const {
  return opcode_.Get();
}
inline void EmulatorActions_Instruction::_internal_set_opcode(const std::string& value) {
  
  opcode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void EmulatorActions_Instruction::set_opcode(std::string&& value) {
  
  opcode_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:EmulatorActions.Instruction.opcode)
}
inline void EmulatorActions_Instruction::set_opcode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  opcode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:EmulatorActions.Instruction.opcode)
}
inline void EmulatorActions_Instruction::set_opcode(const void* value,
    size_t size) {
  
  opcode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:EmulatorActions.Instruction.opcode)
}
inline std::string* EmulatorActions_Instruction::_internal_mutable_opcode() {
  
  return opcode_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* EmulatorActions_Instruction::release_opcode() {
  // @@protoc_insertion_point(field_release:EmulatorActions.Instruction.opcode)
  return opcode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EmulatorActions_Instruction::set_allocated_opcode(std::string* opcode) {
  if (opcode != nullptr) {
    
  } else {
    
  }
  opcode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), opcode,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:EmulatorActions.Instruction.opcode)
}
inline std::string* EmulatorActions_Instruction::unsafe_arena_release_opcode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:EmulatorActions.Instruction.opcode)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return opcode_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void EmulatorActions_Instruction::unsafe_arena_set_allocated_opcode(
    std::string* opcode) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (opcode != nullptr) {
    
  } else {
    
  }
  opcode_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      opcode, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EmulatorActions.Instruction.opcode)
}

// uint64 addr = 2;
inline void EmulatorActions_Instruction::clear_addr() {
  addr_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EmulatorActions_Instruction::_internal_addr() const {
  return addr_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EmulatorActions_Instruction::addr() const {
  // @@protoc_insertion_point(field_get:EmulatorActions.Instruction.addr)
  return _internal_addr();
}
inline void EmulatorActions_Instruction::_internal_set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  addr_ = value;
}
inline void EmulatorActions_Instruction::set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_addr(value);
  // @@protoc_insertion_point(field_set:EmulatorActions.Instruction.addr)
}

// uint64 size = 3;
inline void EmulatorActions_Instruction::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EmulatorActions_Instruction::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EmulatorActions_Instruction::size() const {
  // @@protoc_insertion_point(field_get:EmulatorActions.Instruction.size)
  return _internal_size();
}
inline void EmulatorActions_Instruction::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  size_ = value;
}
inline void EmulatorActions_Instruction::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:EmulatorActions.Instruction.size)
}

// .EmulatorActions.MemoryAccess memory_access = 4;
inline bool EmulatorActions_Instruction::_internal_has_memory_access() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || memory_access_ != nullptr);
  return value;
}
inline bool EmulatorActions_Instruction::has_memory_access() const {
  return _internal_has_memory_access();
}
inline void EmulatorActions_Instruction::clear_memory_access() {
  if (GetArena() == nullptr && memory_access_ != nullptr) {
    delete memory_access_;
  }
  memory_access_ = nullptr;
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::EmulatorActions_MemoryAccess& EmulatorActions_Instruction::_internal_memory_access() const {
  const ::EmulatorActions_MemoryAccess* p = memory_access_;
  return p != nullptr ? *p : *reinterpret_cast<const ::EmulatorActions_MemoryAccess*>(
      &::_EmulatorActions_MemoryAccess_default_instance_);
}
inline const ::EmulatorActions_MemoryAccess& EmulatorActions_Instruction::memory_access() const {
  // @@protoc_insertion_point(field_get:EmulatorActions.Instruction.memory_access)
  return _internal_memory_access();
}
inline void EmulatorActions_Instruction::unsafe_arena_set_allocated_memory_access(
    ::EmulatorActions_MemoryAccess* memory_access) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(memory_access_);
  }
  memory_access_ = memory_access;
  if (memory_access) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EmulatorActions.Instruction.memory_access)
}
inline ::EmulatorActions_MemoryAccess* EmulatorActions_Instruction::release_memory_access() {
  auto temp = unsafe_arena_release_memory_access();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::EmulatorActions_MemoryAccess* EmulatorActions_Instruction::unsafe_arena_release_memory_access() {
  // @@protoc_insertion_point(field_release:EmulatorActions.Instruction.memory_access)
  _has_bits_[0] &= ~0x00000001u;
  ::EmulatorActions_MemoryAccess* temp = memory_access_;
  memory_access_ = nullptr;
  return temp;
}
inline ::EmulatorActions_MemoryAccess* EmulatorActions_Instruction::_internal_mutable_memory_access() {
  _has_bits_[0] |= 0x00000001u;
  if (memory_access_ == nullptr) {
    auto* p = CreateMaybeMessage<::EmulatorActions_MemoryAccess>(GetArena());
    memory_access_ = p;
  }
  return memory_access_;
}
inline ::EmulatorActions_MemoryAccess* EmulatorActions_Instruction::mutable_memory_access() {
  // @@protoc_insertion_point(field_mutable:EmulatorActions.Instruction.memory_access)
  return _internal_mutable_memory_access();
}
inline void EmulatorActions_Instruction::set_allocated_memory_access(::EmulatorActions_MemoryAccess* memory_access) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete memory_access_;
  }
  if (memory_access) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(memory_access);
    if (message_arena != submessage_arena) {
      memory_access = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, memory_access, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  memory_access_ = memory_access;
  // @@protoc_insertion_point(field_set_allocated:EmulatorActions.Instruction.memory_access)
}

// .EmulatorActions.BranchFlow branch_flow = 5;
inline bool EmulatorActions_Instruction::_internal_has_branch_flow() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || branch_flow_ != nullptr);
  return value;
}
inline bool EmulatorActions_Instruction::has_branch_flow() const {
  return _internal_has_branch_flow();
}
inline void EmulatorActions_Instruction::clear_branch_flow() {
  if (GetArena() == nullptr && branch_flow_ != nullptr) {
    delete branch_flow_;
  }
  branch_flow_ = nullptr;
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::EmulatorActions_BranchFlow& EmulatorActions_Instruction::_internal_branch_flow() const {
  const ::EmulatorActions_BranchFlow* p = branch_flow_;
  return p != nullptr ? *p : *reinterpret_cast<const ::EmulatorActions_BranchFlow*>(
      &::_EmulatorActions_BranchFlow_default_instance_);
}
inline const ::EmulatorActions_BranchFlow& EmulatorActions_Instruction::branch_flow() const {
  // @@protoc_insertion_point(field_get:EmulatorActions.Instruction.branch_flow)
  return _internal_branch_flow();
}
inline void EmulatorActions_Instruction::unsafe_arena_set_allocated_branch_flow(
    ::EmulatorActions_BranchFlow* branch_flow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(branch_flow_);
  }
  branch_flow_ = branch_flow;
  if (branch_flow) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EmulatorActions.Instruction.branch_flow)
}
inline ::EmulatorActions_BranchFlow* EmulatorActions_Instruction::release_branch_flow() {
  auto temp = unsafe_arena_release_branch_flow();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::EmulatorActions_BranchFlow* EmulatorActions_Instruction::unsafe_arena_release_branch_flow() {
  // @@protoc_insertion_point(field_release:EmulatorActions.Instruction.branch_flow)
  _has_bits_[0] &= ~0x00000002u;
  ::EmulatorActions_BranchFlow* temp = branch_flow_;
  branch_flow_ = nullptr;
  return temp;
}
inline ::EmulatorActions_BranchFlow* EmulatorActions_Instruction::_internal_mutable_branch_flow() {
  _has_bits_[0] |= 0x00000002u;
  if (branch_flow_ == nullptr) {
    auto* p = CreateMaybeMessage<::EmulatorActions_BranchFlow>(GetArena());
    branch_flow_ = p;
  }
  return branch_flow_;
}
inline ::EmulatorActions_BranchFlow* EmulatorActions_Instruction::mutable_branch_flow() {
  // @@protoc_insertion_point(field_mutable:EmulatorActions.Instruction.branch_flow)
  return _internal_mutable_branch_flow();
}
inline void EmulatorActions_Instruction::set_allocated_branch_flow(::EmulatorActions_BranchFlow* branch_flow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete branch_flow_;
  }
  if (branch_flow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(branch_flow);
    if (message_arena != submessage_arena) {
      branch_flow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, branch_flow, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  branch_flow_ = branch_flow;
  // @@protoc_insertion_point(field_set_allocated:EmulatorActions.Instruction.branch_flow)
}

// -------------------------------------------------------------------

// EmulatorActions

// repeated .EmulatorActions.Instruction instructions = 1;
inline int EmulatorActions::_internal_instructions_size() const {
  return instructions_.size();
}
inline int EmulatorActions::instructions_size() const {
  return _internal_instructions_size();
}
inline void EmulatorActions::clear_instructions() {
  instructions_.Clear();
}
inline ::EmulatorActions_Instruction* EmulatorActions::mutable_instructions(int index) {
  // @@protoc_insertion_point(field_mutable:EmulatorActions.instructions)
  return instructions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EmulatorActions_Instruction >*
EmulatorActions::mutable_instructions() {
  // @@protoc_insertion_point(field_mutable_list:EmulatorActions.instructions)
  return &instructions_;
}
inline const ::EmulatorActions_Instruction& EmulatorActions::_internal_instructions(int index) const {
  return instructions_.Get(index);
}
inline const ::EmulatorActions_Instruction& EmulatorActions::instructions(int index) const {
  // @@protoc_insertion_point(field_get:EmulatorActions.instructions)
  return _internal_instructions(index);
}
inline ::EmulatorActions_Instruction* EmulatorActions::_internal_add_instructions() {
  return instructions_.Add();
}
inline ::EmulatorActions_Instruction* EmulatorActions::add_instructions() {
  // @@protoc_insertion_point(field_add:EmulatorActions.instructions)
  return _internal_add_instructions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EmulatorActions_Instruction >&
EmulatorActions::instructions() const {
  // @@protoc_insertion_point(field_list:EmulatorActions.instructions)
  return instructions_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_emulator_2eproto
